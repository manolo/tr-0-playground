    <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nested Flex Containers Playground</title>
  <style>
    :root { --gap: 8px; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      margin: 16px;
    }
    h1 { margin: 0 0 12px; font-size: 1.25rem; }



    .main-layout {
      display: grid;
      grid-template-columns: 365px 1fr;
      gap: 20px;
      height: calc(100vh - 60px);
    }

    .controls-panel {
      border: 1px solid #ccc;
      border-radius: 12px;
      padding: 16px;
      background: #f9f9f9;
      overflow-y: auto;
    }

    .container-panel {
      border: 1px solid #333;
      border-radius: 12px;
      padding: 16px;
      background: #f6f6f6;
      overflow: auto;
      display: block;
    }

    #problemsContainer {
      height: 50%;
    }

    .problem-container {
      display: flex;
      width: 100%;
      height: 100%;
      border: 2px solid #666;
      background: #fafafa;
      gap: var(--gap);
      padding: 12px;
      box-sizing: border-box;
      position: relative;
      border-radius: 8px;
      pointer-events: none; /* Make it non-interactive */
      opacity: 0.95; /* Slightly muted to show it's read-only */
    }

    .problem-container::before {
      content: "Problem";
      position: absolute;
      top: -2px;
      left: 8px;
      background: #666;
      color: white;
      padding: 2px 8px;
      font-size: 0.75rem;
      font-weight: 600;
      border-radius: 0 0 4px 4px;
    }

    /* Root container */
    .root-container {
      display: flex;
      width: 100%;
      height: 50%;
      border: 3px solid #333;
      background: #fff;
      gap: var(--gap);
      padding: 12px;
      box-sizing: border-box;
      position: relative;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .root-container:hover:not(:has(.nested-container:hover)):not(:has(.flex-item:hover)) {
      background: #ffcdd2;
      border-color: #e74c3c;
    }

    .root-container.selected {
      border-color: #ff8f00;
      background: #ffcc80;
      box-shadow: 0 0 0 2px rgba(255, 143, 0, 0.4);
      border-radius: 12px;
      transform: scale(1.002);
    }

    .root-container::before {
      content: "Root Container";
      position: absolute;
      top: -3px;
      left: 8px;
      background: #333;
      color: white;
      padding: 2px 8px;
      font-size: 0.75rem;
      font-weight: 600;
      border-radius: 0 0 4px 4px;
    }

    /* Nested containers */
    .nested-container {
      display: flex;
      border: 2px solid #e74c3c;
      background: #ffebee;
      gap: 6px;
      padding: 8px;
      box-sizing: border-box;
      position: relative;
      min-width: 100px;
      min-height: 80px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .nested-container:hover:not(:has(.nested-container:hover)):not(:has(.flex-item:hover)) {
      background: #ffcdd2;
    }

    .nested-container.selected {
      border-color: #ff8f00;
      background: #ffcc80;
      box-shadow: 0 0 0 2px rgba(255, 143, 0, 0.4);
      border-radius: 8px;
      transform: scale(1.005);
    }

    .nested-container::before {
      content: attr(data-label);
      position: absolute;
      top: -2px;
      left: 8px;
      background: #e74c3c;
      color: white;
      padding: 1px 6px;
      font-size: 0.7rem;
      font-weight: 600;
      border-radius: 0 0 3px 3px;
    }

    .nested-container.selected::before {
      background: #ff6b35;
    }

    /* Items within nested containers */
    .flex-item {
      background: #2d6cdf;
      color: #fff;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      padding: 8px;
      min-width: 30px;
      min-height: 30px;
      font-size: 0.8rem;
      box-sizing: border-box;
      flex-shrink: 0;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .flex-item:hover {
      background: #1a4fb8;
    }

    .flex-item.selected-item {
      background: #28a745;
      box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.4);
      transform: scale(1.05);
    }

    /* Different item sizes */
    .item-small { font-size: 0.7rem; }
    .item-medium { font-size: 0.9rem; }
    .item-large { font-size: 1.1rem; }
    .item-xl { font-size: 1.3rem; }
    .item-xxl { font-size: 1.5rem; }

    fieldset {
      border: 1px solid #bbb;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }
    legend {
      padding: 0 8px;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 12px;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .control-row label {
      font-size: 0.8rem;
      min-width: 85px;
    }

    .radio-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .radio-group label {
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 4px;
      min-width: auto;
    }

    .direction-arrow {
      color: #28a745;
      font-weight: bold;
      font-size: 1rem;
      margin-left: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .direction-arrow::before {
      content: "â†’";
      display: inline-block;
      transition: transform 0.2s ease;
    }

    .direction-arrow.up::before {
      transform: rotate(-90deg);
    }

    .direction-arrow.down::before {
      transform: rotate(90deg);
    }

    .direction-arrow.left::before {
      transform: rotate(180deg);
    }

    .justify-arrow {
      color: #28a745;
      font-weight: bold;
      font-size: 1rem;
      margin-left: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .justify-arrow::before {
      content: "â†”";
      display: inline-block;
      transition: transform 0.2s ease;
    }

    .justify-arrow.vertical::before {
      transform: rotate(90deg);
    }

    .align-arrow {
      color: #dc3545;
      font-weight: bold;
      font-size: 1rem;
      margin-left: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .align-arrow::before {
      content: "â†”";
      display: inline-block;
      transition: transform 0.2s ease;
    }

    .align-arrow.vertical::before {
      transform: rotate(90deg);
    }

    .wrap-arrow {
      color: #6f42c1;
      font-weight: bold;
      font-size: 1rem;
      margin-left: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .wrap-arrow::before {
      content: "â†·";
      display: inline-block;
      transition: transform 0.2s ease;
      font-size: large;
    }

    /* Row direction wrap arrows */
    .wrap-arrow.down-right::before {
      transform: rotate(90deg); /* â†· rotated 90Â° = curves down-right */
    }

    .wrap-arrow.up-right::before {
      transform: rotate(-90deg); /* â†· rotated -90Â° = curves up-right */
    }

    .wrap-arrow.down-left::before {
      transform: rotate(90deg) scaleX(-1); /* â†· rotated 90Â° + flipped = curves down-left */
    }

    .wrap-arrow.up-left::before {
      transform: rotate(-90deg) scaleX(-1); /* â†· rotated -90Â° + flipped = curves up-left */
    }

    /* Column direction wrap arrows */
    .wrap-arrow.column-down-right::before {
      transform: scaleY(-1); /* â†· flipped = curves down-right for columns */
    }

    .wrap-arrow.column-up-right::before {
      transform: scaleX(1) scaleY(1); /* â†· flipped both ways = curves up-right for columns */
    }

    .wrap-arrow.right-down::before {
      transform: scaleX(-1); /* â†· flipped = curves right-down */
    }

    .wrap-arrow.left-down::before {
      transform: rotate(180deg); /* â†· rotated 180Â° = curves left-down */
    }

    .wrap-arrow.right-up::before {
      transform: scaleX(-1) scaleY(-1); /* â†· flipped both ways = curves right-up */
    }

    .wrap-arrow.left-up::before {
      transform: rotate(180deg) scaleY(-1); /* â†· rotated 180Â° + flipped vertically = curves left-up */
    }

    .selected-container-info {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 16px;
      font-size: 0.85rem;
    }

    .btn {
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #888;
      background: #fafafa;
      font-size: 0.8rem;
      margin: 2px;
    }
    .btn:hover { background: #f0f0f0; }

    .btn.small { padding: 4px 8px; font-size: 0.75rem; }

    .info-display {
      background: #e3f2fd;
      border: 1px solid #90caf9;
      border-radius: 6px;
      padding: 8px;
      margin-top: 12px;
      font-size: 0.75rem;
      font-family: monospace;
      white-space: pre-wrap;
    }

    .container-hierarchy {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 0.8rem;
    }

    .hierarchy-item {
      padding: 2px 0;
      cursor: pointer;
      border-radius: 3px;
      padding-left: 8px;
    }

    .hierarchy-item:hover {
      background: #e9ecef;
    }

    .hierarchy-item.selected {
      background: #fff3e0;
      font-weight: 600;
    }

    .hierarchy-item.root {
      font-weight: 600;
      color: #333;
    }

    .hierarchy-item.nested {
      margin-left: 16px;
      color: #e74c3c;
    }
  </style>
</head>
<body>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 0 20px;">
    <h1 style="margin: 0;">Nested Flex Containers Playground</h1>
    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
      <button class="btn small" id="addContainer">Add Container</button>
      <button class="btn small" id="removeContainer">Remove Container</button>
      <button class="btn small" id="addItem">Add Item</button>
      <button class="btn small" id="removeItem">Remove Item</button>
      <button class="btn small" id="resetAll">Reset</button>
      <button class="btn small" id="randomizeLayout">Randomize</button>
      <button class="btn small" id="createProblem">Exercise</button>
    </div>
  </div>

  <div class="main-layout">
    <div class="controls-panel">
      <fieldset>
        <legend>Container Hierarchy</legend>
        <div style="margin-bottom: 8px;">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 0.9rem; cursor: pointer;">
            <input type="checkbox" id="selectAllContainersToggle" style="margin: 0;">
            <span>All Containers</span>
          </label>
        </div>
        <div class="container-hierarchy" id="hierarchy">
          <div class="hierarchy-item root" data-container="root">ðŸ“¦ Root Container</div>
          <div class="hierarchy-item nested" data-container="container1">ðŸ“¦ Container A</div>
          <div class="hierarchy-item nested" data-container="container2">ðŸ“¦ Container B</div>
          <div class="hierarchy-item nested" data-container="container4" style="margin-left: 20px;">ðŸ“¦ Container D</div>
          <div class="hierarchy-item nested" data-container="container5" style="margin-left: 20px;">ðŸ“¦ Container E</div>
          <div class="hierarchy-item nested" data-container="container3">ðŸ“¦ Container C</div>
        </div>
      </fieldset>

      <fieldset id="containerControls" style="display: none;">
        <legend id="controlsTitle">Container Controls</legend>

        <div class="control-group">
          <div class="control-row">
            <label>Direction:<span class="direction-arrow" id="directionArrow"></span></label>
            <div class="radio-group" id="directionGroup">
              <label><input type="radio" name="flexDirection" value="row" checked> row</label>
              <label><input type="radio" name="flexDirection" value="row-reverse"> row-rev</label>
              <label><input type="radio" name="flexDirection" value="column"> column</label>
              <label><input type="radio" name="flexDirection" value="column-reverse"> col-rev</label>
            </div>
          </div>
        </div>

        <div class="control-group">
          <div class="control-row">
            <label>Justify Content:<span class="justify-arrow" id="justifyArrow"></span></label>
            <div class="radio-group" id="justifyGroup">
              <label><input type="radio" name="justifyContent" value="flex-start" checked> start</label>
              <label><input type="radio" name="justifyContent" value="center"> center</label>
              <label><input type="radio" name="justifyContent" value="flex-end"> end</label>
              <label><input type="radio" name="justifyContent" value="space-between"> between</label>
              <label><input type="radio" name="justifyContent" value="space-around"> around</label>
              <label><input type="radio" name="justifyContent" value="space-evenly"> evenly</label>
            </div>
          </div>
        </div>

        <div class="control-group">
          <div class="control-row">
            <label>Align Items:<span class="align-arrow" id="alignArrow"></span></label>
            <div class="radio-group" id="alignItemsGroup">
              <label><input type="radio" name="alignItems" value="stretch" checked> stretch</label>
              <label><input type="radio" name="alignItems" value="flex-start"> start</label>
              <label><input type="radio" name="alignItems" value="center"> center</label>
              <label><input type="radio" name="alignItems" value="flex-end"> end</label>
              <label><input type="radio" name="alignItems" value="baseline"> baseline</label>
            </div>
          </div>
        </div>
        <hr style="margin: 15px 0; border: 1px solid #ddd;">


        <div class="control-group">
          <div class="control-row">
            <label>Flex Wrap:<span class="wrap-arrow" id="wrapArrow"></span></label>
            <div class="radio-group" id="wrapGroup">
              <label><input type="radio" name="flexWrap" value="nowrap" checked> nowrap</label>
              <label><input type="radio" name="flexWrap" value="wrap"> wrap</label>
              <label><input type="radio" name="flexWrap" value="wrap-reverse"> wrap-rev</label>
            </div>
          </div>
        </div>



        <div class="control-group" id="alignContentSection">
          <div class="control-row">
            <label>Align Content:<span class="align-arrow" id="alignContentArrow"></span></label>
            <div class="radio-group" id="alignContentGroup">
              <label><input type="radio" name="alignContent" value="stretch" checked> stretch</label>
              <label><input type="radio" name="alignContent" value="flex-start"> start</label>
              <label><input type="radio" name="alignContent" value="center"> center</label>
              <label><input type="radio" name="alignContent" value="flex-end"> end</label>
              <label><input type="radio" name="alignContent" value="space-between"> between</label>
              <label><input type="radio" name="alignContent" value="space-around"> around</label>
              <label><input type="radio" name="alignContent" value="space-evenly"> evenly</label>
            </div>
          </div>
        </div>
        <hr style="margin: 15px 0; border: 1px solid #ddd;">

        <!-- Container Size Controls -->
        <div class="control-group">
          <div class="control-row" style="flex-wrap: nowrap;">
            <label>Width:</label>
            <input type="range" id="containerWidthRange" min="0" max="100" value="0">
            <input type="text" id="containerWidthValue" placeholder="auto" style="width: 60px;">
          </div>
          <div class="control-row" style="flex-wrap: nowrap;">
            <label>Height:</label>
            <input type="range" id="containerHeightRange" min="0" max="100" value="0">
            <input type="text" id="containerHeightValue" placeholder="auto" style="width: 60px;">
          </div>
        </div>

        <!-- Container Scroll Controls -->
        <div class="control-group">
          <div class="control-row">
            <label>Scroll:</label>
            <div class="radio-group" id="scrollGroup">
              <label><input type="radio" name="containerOverflow" value="visible" checked> none</label>
              <label><input type="radio" name="containerOverflow" value="auto"> auto</label>
              <label><input type="radio" name="containerOverflow" value="scroll"> always</label>
              <label><input type="radio" name="containerOverflow" value="hidden"> hidden</label>
            </div>
          </div>
        </div>

        <!-- Container as Flex Item Properties (only show for nested containers) -->
        <div id="containerAsItemSection" style="display: none;">
          <hr style="margin: 15px 0; border: 1px solid #ddd;">
          <h4 style="margin: 10px 0; color: #666; font-size: 0.9em;">As Flex Item (within parent container):</h4>

          <div class="control-group">
            <div class="control-row">
              <label>Flex Grow:</label>
              <input type="range" id="containerFlexGrowRange" min="0" max="5" step="1" value="0">
              <input type="text" id="containerFlexGrowValue" value="0" style="width: 40px;">
            </div>
            <div class="control-row">
              <label>Flex Shrink:</label>
              <input type="range" id="containerFlexShrinkRange" min="0" max="3" step="1" value="1">
              <input type="text" id="containerFlexShrinkValue" value="1" style="width: 40px;">
            </div>
            <div class="control-row">
              <label>Flex Basis:</label>
              <input type="range" id="containerFlexBasisRange" min="0" max="200" value="0">
              <input type="text" id="containerFlexBasisValue" placeholder="auto" style="width: 50px;">
            </div>
          </div>

          <div class="control-group">
            <label>Align Self:</label>
            <div class="radio-group" id="containerAlignSelfGroup">
              <label><input type="radio" name="containerAlignSelf" value="auto" checked> auto</label>
              <label><input type="radio" name="containerAlignSelf" value="flex-start"> start</label>
              <label><input type="radio" name="containerAlignSelf" value="center"> center</label>
              <label><input type="radio" name="containerAlignSelf" value="flex-end"> end</label>
              <label><input type="radio" name="containerAlignSelf" value="stretch"> stretch</label>
            </div>
          </div>
        </div>
      </fieldset>
      </fieldset>

      <fieldset id="itemControls" style="display: none;">
        <legend id="itemControlsTitle">Selected Item Controls</legend>

        <div class="control-group">
          <div class="control-row">
            <label>Font Size:</label>
            <input type="range" id="fontSizeRange" min="1" max="5" step="1" value="1">
            <input type="text" id="fontSizeValue" value="1em" style="width: 50px;">
          </div>
          <div class="control-row">
            <label>Flex Grow:</label>
            <input type="range" id="itemFlexGrowRange" min="0" max="5" step="1" value="0">
            <input type="text" id="itemFlexGrowValue" value="0" style="width: 40px;">
          </div>
          <div class="control-row">
            <label>Flex Shrink:</label>
            <input type="range" id="itemFlexShrinkRange" min="0" max="3" step="1" value="0">
            <input type="text" id="itemFlexShrinkValue" value="0" style="width: 40px;">
          </div>
          <div class="control-row">
            <label>Flex Basis:</label>
            <input type="range" id="itemFlexBasisRange" min="0" max="200" value="0">
            <input type="text" id="itemFlexBasisValue" placeholder="auto" style="width: 50px;">
          </div>
        </div>

        <div class="control-group">
          <div class="control-row">
            <label>Width:</label>
            <input type="range" id="itemWidthRange" min="0" max="150" value="0">
            <input type="text" id="itemWidthValue" placeholder="auto" style="width: 50px;">
          </div>
          <div class="control-row">
            <label>Height:</label>
            <input type="range" id="itemHeightRange" min="0" max="150" value="0">
            <input type="text" id="itemHeightValue" placeholder="auto" style="width: 50px;">
          </div>
        </div>

        <div class="control-group">
          <label>Align Self:</label>
          <div class="radio-group">
            <label><input type="radio" name="itemAlignSelf" value="auto" checked> auto</label>
            <label><input type="radio" name="itemAlignSelf" value="flex-start"> start</label>
            <label><input type="radio" name="itemAlignSelf" value="center"> center</label>
            <label><input type="radio" name="itemAlignSelf" value="flex-end"> end</label>
            <label><input type="radio" name="itemAlignSelf" value="stretch"> stretch</label>
          </div>
        </div>
      </fieldset>

      <div class="selected-container-info" id="topCSSInfo">
        <div class="control-row" id="topButtons" style="display: none; margin-bottom: 8px;">
          <button class="btn small" id="resetContainer">Reset Container</button>
          <button class="btn small" id="copyContainerCSS">Copy CSS</button>
        </div>
        <div class="info-display" id="cssInfoTop" style="display: none;"></div>
      </div>

    </div>

    <div class="container-panel">
      <div class="root-container" id="rootContainer" data-container="root">
        <div class="nested-container" id="container1" data-container="container1" data-label="Container A">
          <div class="flex-item item-small">A1</div>
          <div class="flex-item item-medium">A2</div>
          <div class="flex-item item-large">A3</div>
          <div class="flex-item item-xl">A4</div>
          <div class="flex-item item-xxl">A5</div>
          <div class="flex-item item-large">A6</div>
        </div>

        <div class="nested-container" id="container2" data-container="container2" data-label="Container B">
          <div class="nested-container" id="container4" data-container="container4" data-label="Container D">
            <div class="flex-item item-small">D1</div>
            <div class="flex-item item-medium">D2</div>
            <div class="flex-item item-large">D3</div>
            <div class="flex-item item-xl">D4</div>
            <div class="flex-item item-xxl">D5</div>
            <div class="flex-item item-large">D6</div>
          </div>
          <div class="nested-container" id="container5" data-container="container5" data-label="Container E">
            <div class="flex-item item-small">E1</div>
            <div class="flex-item item-medium">E2</div>
            <div class="flex-item item-large">E3</div>
            <div class="flex-item item-xl">E4</div>
            <div class="flex-item item-xxl">E5</div>
            <div class="flex-item item-large">E6</div>
          </div>
        </div>

        <div class="nested-container" id="container3" data-container="container3" data-label="Container C">
          <div class="flex-item item-small">C1</div>
          <div class="flex-item item-medium">C2</div>
          <div class="flex-item item-large">C3</div>
          <div class="flex-item item-xl">C4</div>
          <div class="flex-item item-xxl">C5</div>
          <div class="flex-item item-large">C6</div>
        </div>
      </div>

      <div id="problemsContainer"></div>
    </div>
  </div>

  <script>
    let selectedContainer = null;
    let selectedContainers = []; // Array to track multiple selected containers
    let isMultiSelectMode = false; // Flag to indicate if we're in multi-select mode
    let lastClickedContainer = null; // For shift-click range selection of containers
    let selectedItem = null;
    let selectedItems = []; // Array to track multiple selected items
    let lastClickedItem = null; // For shift-click range selection

    // Helper function to apply styles to all selected items
    function applyStyleToAllItems(property, value) {
      selectedItems.forEach(item => {
        item.style[property] = value;
      });
    }
    let containerCounter = 5;
    let itemCounter = { container1: 6, container2: 0, container3: 6, container4: 6, container5: 6 };

    // Helper function to update button states based on current selection
    function updateButtonStates() {
      const addContainerBtn = document.getElementById('addContainer');
      const removeContainerBtn = document.getElementById('removeContainer');
      const addItemBtn = document.getElementById('addItem');
      const removeItemBtn = document.getElementById('removeItem');

      const hasContainerSelected = selectedContainer || selectedContainers.length > 0;
      const hasItemSelected = selectedItem || selectedItems.length > 0;

      if (hasItemSelected) {
        // When item(s) selected: disable all buttons except removeItem
        addContainerBtn.disabled = true;
        removeContainerBtn.disabled = true;
        addItemBtn.disabled = true;
        removeItemBtn.disabled = false;
      } else if (hasContainerSelected) {
        // When container(s) selected: enable all buttons
        addContainerBtn.disabled = false;
        removeContainerBtn.disabled = false;
        addItemBtn.disabled = false;
        removeItemBtn.disabled = true;
      } else {
        // When nothing selected: disable all buttons
        addContainerBtn.disabled = true;
        removeContainerBtn.disabled = true;
        addItemBtn.disabled = true;
        removeItemBtn.disabled = true;
      }
    }

    // Helper function to update the "Select All" checkbox state
    function updateSelectAllCheckbox() {
      // Small delay to ensure DOM is fully updated
      setTimeout(() => {
        const allContainers = document.querySelectorAll('.root-container, .nested-container');
        const allSelected = allContainers.length > 0 && selectedContainers.length === allContainers.length;

        console.log('DEBUG updateSelectAllCheckbox:', {
          allContainersCount: allContainers.length,
          selectedContainersCount: selectedContainers.length,
          allSelected: allSelected,
          selectedIds: selectedContainers.map(c => c.id),
          allContainerIds: Array.from(allContainers).map(c => c.getAttribute('data-container') || c.id)
        });

        const checkbox = document.getElementById('selectAllContainersToggle');

        // Set flag to prevent triggering change event
        isUpdatingCheckbox = true;
        console.log('DEBUG Setting checkbox to:', allSelected);
        checkbox.checked = allSelected;

        // Reset flag after a brief delay
        setTimeout(() => {
          isUpdatingCheckbox = false;
        }, 50);
      }, 10);
    }

    // Container selection
    function selectContainer(containerElement, containerId, event = null) {
      const isCtrlClick = event && (event.ctrlKey || event.metaKey);
      const isShiftClick = event && event.shiftKey;

      console.log('Container clicked:', containerId, 'Ctrl:', isCtrlClick, 'Shift:', isShiftClick);

      // Clear any selected items - containers and items are mutually exclusive
      document.querySelectorAll('.flex-item').forEach(item => {
        item.classList.remove('selected-item');
      });
      selectedItems = [];
      selectedItem = null;
      lastClickedItem = null;
      document.getElementById('itemControls').style.display = 'none';

      if (isShiftClick && lastClickedContainer && lastClickedContainer !== containerElement) {
        // Shift-click: Select range from last clicked container to current
        console.log('Shift-click range selection for containers');
        const allContainers = [...document.querySelectorAll('.nested-container, .root-container')];
        const lastIndex = allContainers.indexOf(lastClickedContainer);
        const currentIndex = allContainers.indexOf(containerElement);

        if (lastIndex !== -1 && currentIndex !== -1) {
          const startIndex = Math.min(lastIndex, currentIndex);
          const endIndex = Math.max(lastIndex, currentIndex);

          // Clear current selection and select range
          selectedContainers = [];
          document.querySelectorAll('.nested-container, .root-container').forEach(container => {
            container.classList.remove('selected');
          });
          document.querySelectorAll('.hierarchy-item').forEach(item => {
            item.classList.remove('selected');
          });

          for (let i = startIndex; i <= endIndex; i++) {
            const container = allContainers[i];
            const id = container.getAttribute('data-container') || container.id;
            if (id) {
              selectedContainers.push({ element: container, id: id });
              container.classList.add('selected');
              const hierarchyItem = document.querySelector(`[data-container="${id}"]`);
              if (hierarchyItem) hierarchyItem.classList.add('selected');
            }
          }
        }
      } else if (isCtrlClick) {
        // Ctrl-click: Toggle this container in selection
        console.log('Ctrl-click toggle for container');
        const existingIndex = selectedContainers.findIndex(c => c.element === containerElement);

        if (existingIndex >= 0) {
          // Remove from selection
          selectedContainers.splice(existingIndex, 1);
          containerElement.classList.remove('selected');
          const hierarchyItem = document.querySelector(`[data-container="${containerId}"]`);
          if (hierarchyItem) hierarchyItem.classList.remove('selected');
        } else {
          // Add to selection
          selectedContainers.push({ element: containerElement, id: containerId });
          containerElement.classList.add('selected');
          const hierarchyItem = document.querySelector(`[data-container="${containerId}"]`);
          if (hierarchyItem) hierarchyItem.classList.add('selected');
        }

        lastClickedContainer = containerElement;
      } else {
        // Normal click: Select only this container
        console.log('Single container selection');

        // Clear all previous selections
        document.querySelectorAll('.nested-container, .root-container').forEach(container => {
          container.classList.remove('selected');
        });
        document.querySelectorAll('.hierarchy-item').forEach(item => {
          item.classList.remove('selected');
        });

        selectedContainers = [{ element: containerElement, id: containerId }];
        containerElement.classList.add('selected');
        const hierarchyItem = document.querySelector(`[data-container="${containerId}"]`);
        if (hierarchyItem) hierarchyItem.classList.add('selected');
        lastClickedContainer = containerElement;
      }

      // Update selectedContainer for backward compatibility
      selectedContainer = selectedContainers.length > 0 ? selectedContainers[0] : null;

      // Show container-specific UI elements
      showContainerUI();

      // Show controls
      document.getElementById('containerControls').style.display = 'block';

      // Get container display name
      let displayName;
      if (selectedContainers.length > 1) {
        displayName = `${selectedContainers.length} Containers`;
      } else if (containerId === 'root') {
        displayName = 'Root Container';
      } else {
        const dataLabel = containerElement.getAttribute('data-label');
        displayName = dataLabel || (containerId.charAt(0).toUpperCase() + containerId.slice(1));
      }
      document.getElementById('controlsTitle').textContent = `${displayName} Controls`;

      // Show/hide container as item section (hide only if root is selected)
      const containerAsItemSection = document.getElementById('containerAsItemSection');
      const hasRootSelected = selectedContainers.some(container => container.id === 'root' || container.id === 'rootContainer');
      if (hasRootSelected) {
        containerAsItemSection.style.display = 'none';
      } else {
        containerAsItemSection.style.display = 'block';
      }

      // Update controls with current values
      updateControlsFromContainer();
      updateCSSDisplay();

      // Hide item controls when container is selected
      document.getElementById('itemControls').style.display = 'none';
      selectedItem = null;
      selectedItems = [];
      lastClickedItem = null;
      document.querySelectorAll('.flex-item').forEach(item => {
        item.classList.remove('selected-item');
      });

      // Update button states and checkbox state
      console.log('DEBUG After selectContainer:', {
        selectedContainersCount: selectedContainers.length,
        selectedIds: selectedContainers.map(c => c.id)
      });
      updateButtonStates();
      updateSelectAllCheckbox();
    }

    function selectAllContainers() {
      // Clear previous selections
      clearSelection();

      // Enter multi-select mode
      isMultiSelectMode = true;
      selectedContainers = [];

      // Select all containers
      const allContainers = document.querySelectorAll('.root-container, .nested-container');
      allContainers.forEach(container => {
        const containerId = container.getAttribute('data-container') || container.id;
        container.classList.add('selected');
        selectedContainers.push({ element: container, id: containerId });

        // Update hierarchy selection
        const hierarchyItem = document.querySelector(`[data-container="${containerId}"]`);
        if (hierarchyItem) {
          hierarchyItem.classList.add('selected');
        }
      });

      // Set the first container as primary selected container for controls
      if (selectedContainers.length > 0) {
        selectedContainer = selectedContainers[0];
      }

      // Show container-specific UI elements
      showContainerUI();

      // Show controls
      document.getElementById('containerControls').style.display = 'block';
      document.getElementById('controlsTitle').textContent = `${selectedContainers.length} Containers Selected`;

      // Show/hide container as item section (hide only if root is selected)
      const containerAsItemSection = document.getElementById('containerAsItemSection');
      const hasRootSelected = selectedContainers.some(container => container.id === 'root' || container.id === 'rootContainer');
      if (hasRootSelected) {
        containerAsItemSection.style.display = 'none';
      } else {
        containerAsItemSection.style.display = 'block';
      }

      // Update controls and CSS display
      updateControlsFromContainer();
      updateCSSDisplay();
      updateButtonStates();
      updateSelectAllCheckbox();

      // Hide item controls
      document.getElementById('itemControls').style.display = 'none';
      selectedItem = null;
      selectedItems = [];
      lastClickedItem = null;
      document.querySelectorAll('.flex-item').forEach(item => {
        item.classList.remove('selected-item');
      });
    }

    function hideContainerUI() {
      // Hide container-specific elements when no container is selected
      document.getElementById('containerControls').style.display = 'none';
      document.getElementById('topButtons').style.display = 'none';
      document.getElementById('cssInfoTop').style.display = 'none';
    }

    function showContainerUI() {
      // Show container-specific elements when a container is selected
      document.getElementById('topButtons').style.display = 'block';
      document.getElementById('cssInfoTop').style.display = 'block';

      // Update button labels for container context
      document.getElementById('resetContainer').textContent = 'Reset Container';
      document.getElementById('copyContainerCSS').textContent = 'Copy CSS';
    }

    function clearSelection() {
      // Clear all selections
      document.querySelectorAll('.nested-container, .root-container').forEach(container => {
        container.classList.remove('selected');
      });
      document.querySelectorAll('.hierarchy-item').forEach(item => {
        item.classList.remove('selected');
      });
      document.querySelectorAll('.flex-item').forEach(item => {
        item.classList.remove('selected-item');
      });

      selectedContainer = null;
      selectedContainers = [];
      lastClickedContainer = null;
      isMultiSelectMode = false;
      selectedItem = null;
      selectedItems = [];
      lastClickedItem = null;

      // Hide all UI elements that are specific to selections
      hideContainerUI();
      document.getElementById('itemControls').style.display = 'none';

      // Update button states and checkbox state
      updateButtonStates();
      updateSelectAllCheckbox();
    }

    // Item selection
    function selectItem(itemElement, event = null) {
      const isCtrlClick = event && (event.ctrlKey || event.metaKey);
      const isShiftClick = event && event.shiftKey;
      console.log('selectItem called:', itemElement.textContent, 'isCtrlClick:', isCtrlClick, 'isShiftClick:', isShiftClick);

      // Hide container controls and clear container selections - items and containers are mutually exclusive
      document.getElementById('containerControls').style.display = 'none';
      selectedContainer = null;
      selectedContainers = [];
      lastClickedContainer = null;
      document.querySelectorAll('.nested-container, .root-container').forEach(container => {
        container.classList.remove('selected');
      });
      document.querySelectorAll('.hierarchy-item').forEach(item => {
        item.classList.remove('selected');
      });

      if (isShiftClick && lastClickedItem && lastClickedItem !== itemElement) {
        // Shift-click: Select range from last clicked to current
        const allItems = Array.from(document.querySelectorAll('.flex-item'));
        const startIndex = allItems.indexOf(lastClickedItem);
        const endIndex = allItems.indexOf(itemElement);
        const minIndex = Math.min(startIndex, endIndex);
        const maxIndex = Math.max(startIndex, endIndex);

        // Clear previous selection
        document.querySelectorAll('.flex-item').forEach(item => {
          item.classList.remove('selected-item');
        });
        selectedItems = [];

        // Select range
        for (let i = minIndex; i <= maxIndex; i++) {
          const item = allItems[i];
          item.classList.add('selected-item');
          selectedItems.push(item);
        }

        selectedItem = itemElement;
      } else if (isCtrlClick) {
        // Ctrl/Cmd-click: Toggle individual item
        if (itemElement.classList.contains('selected-item')) {
          // Remove from selection
          itemElement.classList.remove('selected-item');
          selectedItems = selectedItems.filter(item => item !== itemElement);
          selectedItem = selectedItems[0] || null;
        } else {
          // Add to selection
          itemElement.classList.add('selected-item');
          selectedItems.push(itemElement);
          selectedItem = itemElement;
        }
      } else {
        // Normal click: Select single item
        document.querySelectorAll('.flex-item').forEach(item => {
          item.classList.remove('selected-item');
        });
        selectedItems = [itemElement];
        selectedItem = itemElement;
        itemElement.classList.add('selected-item');
      }

      lastClickedItem = itemElement;

      // Show item controls
      if (selectedItems.length > 0) {
        document.getElementById('itemControls').style.display = 'block';
        const titleText = selectedItems.length === 1
          ? `Item: ${selectedItems[0].textContent}`
          : `Items: ${selectedItems.length} selected`;
        document.getElementById('itemControlsTitle').textContent = titleText;

        // Show CSS info and buttons at top for items
        document.getElementById('cssInfoTop').style.display = 'block';
        document.getElementById('topButtons').style.display = 'block';

        // Update button labels for item context
        document.getElementById('resetContainer').textContent = selectedItems.length === 1 ? 'Reset Item' : 'Reset Items';
        document.getElementById('copyContainerCSS').textContent = 'Copy CSS';
      } else {
        document.getElementById('itemControls').style.display = 'none';
      }

      // Update item controls with current values
      updateItemControlsFromElement();
      updateItemCSSDisplay();

      // Update button states and checkbox state
      updateButtonStates();
      updateSelectAllCheckbox();
    }

    // Click handlers
    document.getElementById('rootContainer').addEventListener('click', (e) => {
      if (e.target.id === 'rootContainer' || e.target.classList.contains('root-container')) {
        const containerId = e.target.getAttribute('data-container') || 'root';
        selectContainer(document.getElementById('rootContainer'), containerId, e);
        e.stopPropagation();
      }
    });

    document.addEventListener('click', (e) => {
      // Ignore clicks on problem containers and their children
      if (e.target.classList.contains('problem-container') ||
          e.target.closest('.problem-container')) {
        return;
      }

      if (e.target.classList.contains('flex-item')) {
        console.log('Item clicked:', e.target.textContent, 'Ctrl:', e.ctrlKey, 'Meta:', e.metaKey, 'Shift:', e.shiftKey);
        selectItem(e.target, e);
        e.stopPropagation();
      } else if (e.target.classList.contains('nested-container')) {
        selectContainer(e.target, e.target.getAttribute('data-container'), e);
        e.stopPropagation();
      } else if (e.target.classList.contains('container-panel') ||
                 e.target.classList.contains('playground') ||
                 e.target === document.body) {
        // Clear all selections when clicking in empty areas
        clearSelection();
        e.stopPropagation();
      }
    });

    // Escape key handler to clear all selections
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        clearSelection();
        e.preventDefault();
      }
    });

    // Hierarchy click handlers
    document.getElementById('hierarchy').addEventListener('click', (e) => {
      if (e.target.classList.contains('hierarchy-item')) {
        const containerId = e.target.getAttribute('data-container');
        const containerElement = containerId === 'root'
          ? document.getElementById('rootContainer')
          : document.getElementById(containerId);
        selectContainer(containerElement, containerId, e);
      }
    });

    // Property controls
    function setupPropertyControl(propertyName) {
      document.querySelectorAll(`input[name="${propertyName}"]`).forEach(radio => {
        radio.addEventListener('change', (e) => {
          if (selectedContainer) {
            applyStyleToAllSelected(propertyName, e.target.value);
            updateCSSDisplay();
          }
        });
      });
    }

    // Function to update direction arrow
    function updateDirectionArrow(direction) {
      const arrow = document.getElementById('directionArrow');
      if (!arrow) return;

      // Remove all direction classes
      arrow.className = 'direction-arrow';

      // Add appropriate class for rotation
      switch(direction) {
        case 'row':
          // Default â†’ (no additional class needed)
          break;
        case 'row-reverse':
          arrow.classList.add('left');
          break;
        case 'column':
          arrow.classList.add('down');
          break;
        case 'column-reverse':
          arrow.classList.add('up');
          break;
      }

      // Update justify and align arrows based on direction
      updateJustifyAndAlignArrows(direction);

      // Update wrap arrow (need to get current wrap value)
      const currentWrap = selectedContainer ?
        (selectedContainer.element.style.flexWrap || 'nowrap') : 'nowrap';
      updateWrapArrow(direction, currentWrap);
    }

    // Function to update justify-content and align-items arrows based on direction
    function updateJustifyAndAlignArrows(direction) {
      const justifyArrow = document.getElementById('justifyArrow');
      const alignArrow = document.getElementById('alignArrow');
      const alignContentArrow = document.getElementById('alignContentArrow');

      if (!justifyArrow || !alignArrow) return;

      // Reset classes
      justifyArrow.className = 'justify-arrow';
      alignArrow.className = 'align-arrow';
      if (alignContentArrow) {
        alignContentArrow.className = 'align-arrow';
      }

      // For row directions: justify-content works horizontally, align-items vertically
      // For column directions: justify-content works vertically, align-items horizontally
      if (direction === 'column' || direction === 'column-reverse') {
        justifyArrow.classList.add('vertical'); // main axis is vertical
        // alignArrow and alignContentArrow stay horizontal (cross axis)
      } else { // row or row-reverse
        // justifyArrow stays horizontal (main axis)
        alignArrow.classList.add('vertical'); // cross axis is vertical
        if (alignContentArrow) {
          alignContentArrow.classList.add('vertical'); // cross axis is vertical
        }
      }
    }

    // Function to update wrap arrow based on direction and wrap value
    function updateWrapArrow(direction, wrapValue) {
      const wrapArrow = document.getElementById('wrapArrow');
      if (!wrapArrow) return;

      // Reset classes
      wrapArrow.className = 'wrap-arrow';

      if (wrapValue === 'nowrap') {
        // Hide the arrow for nowrap
        wrapArrow.style.display = 'none';
        return;
      } else {
        wrapArrow.style.display = 'inline-block';
      }

      // Determine wrap direction based on flex-direction and flex-wrap
      // The wrap direction depends on both the main axis direction AND wrap type
      if (direction === 'row') {
        // Row: items flow leftâ†’right
        if (wrapValue === 'wrap') {
          wrapArrow.classList.add('down-right'); // wrap down-right (CORRECT per user)
        } else { // wrap-reverse
          wrapArrow.classList.add('down-left'); // SWAPPED: should be down-left
        }
      } else if (direction === 'row-reverse') {
        // Row-reverse: items flow rightâ†’left
        if (wrapValue === 'wrap') {
          wrapArrow.classList.add('up-left'); // SWITCHED: was up-right
        } else { // wrap-reverse
          wrapArrow.classList.add('up-right'); // SWITCHED: was up-left
        }
      } else if (direction === 'column') {
        // Column: items flow topâ†’bottom (down), then wrap right
        if (wrapValue === 'wrap') {
          wrapArrow.classList.add('column-down-right'); // Flow down, then wrap right
        } else { // wrap-reverse
          wrapArrow.classList.add('left-down'); // wrap left-down (CORRECT per user)
        }
      } else { // column-reverse
        // Column-reverse: items flow bottomâ†’top (up), then wrap right
        if (wrapValue === 'wrap') {
          wrapArrow.classList.add('column-up-right'); // Flow up, then wrap right
        } else { // wrap-reverse
          wrapArrow.classList.add('left-up'); // wrap left-up (CORRECT per user)
        }
      }
    }

    // Enhanced setupPropertyControl for flexDirection
    function setupPropertyControl(propertyName) {
      document.querySelectorAll(`input[name="${propertyName}"]`).forEach(radio => {
        radio.addEventListener('change', (e) => {
          if (selectedContainer) {
            applyStyleToAllSelected(propertyName, e.target.value);
            updateCSSDisplay();

            // Update arrow for direction changes
            if (propertyName === 'flexDirection') {
              updateDirectionArrow(e.target.value);
            }
          }
        });
      });
    }

    // Initialize property controls
    setupPropertyControl('flexDirection');
    setupPropertyControl('justifyContent');
    setupPropertyControl('alignItems');
    setupPropertyControl('alignContent');

    // Container scroll controls - special handling for overflow
    document.querySelectorAll('input[name="containerOverflow"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        if (selectedContainer) {
          applyStyleToAllSelected('overflow', e.target.value);
          updateCSSDisplay();
        }
      });
    });

    // Special handling for flexWrap to enable/disable align-content
    document.querySelectorAll('input[name="flexWrap"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        if (selectedContainer) {
          applyStyleToAllSelected('flexWrap', e.target.value);
          updateCSSDisplay();

          // Update wrap arrow
          const currentDirection = selectedContainer.element.style.flexDirection || 'row';
          updateWrapArrow(currentDirection, e.target.value);
        }

        // Enable/disable align-content section based on wrap setting
        const alignContentSection = document.getElementById('alignContentSection');
        const isWrapEnabled = e.target.value !== 'nowrap';

        if (isWrapEnabled) {
          alignContentSection.style.opacity = '1';
          alignContentSection.style.pointerEvents = 'auto';
        } else {
          alignContentSection.style.opacity = '0.5';
          alignContentSection.style.pointerEvents = 'none';
        }
      });
    });

    // Container as flex item controls - special handling for align-self
    document.querySelectorAll('input[name="containerAlignSelf"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        if (selectedContainer) {
          applyStyleToAllSelected('alignSelf', e.target.value);
          updateCSSDisplay();
        }
      });
    });

    // Container flex item range controls
    function setupContainerRangeControl(property, rangeId, valueId, unit = '') {
      const range = document.getElementById(rangeId);
      const valueInput = document.getElementById(valueId);

      range.addEventListener('input', (e) => {
        const value = e.target.value;
        const shouldBeAuto = value === '0' && (property.includes('Basis') || property === 'width' || property === 'height');
        valueInput.value = shouldBeAuto ? 'auto' : value + unit;
        if (selectedContainer) {
          if (shouldBeAuto) {
            applyStyleToAllSelected(property, 'auto');
          } else {
            applyStyleToAllSelected(property, value + unit);
          }
          updateCSSDisplay();
        }
      });

      valueInput.addEventListener('input', (e) => {
        if (selectedContainer) {
          applyStyleToAllSelected(property, e.target.value);
          updateCSSDisplay();
        }
      });
    }

    setupContainerRangeControl('flexGrow', 'containerFlexGrowRange', 'containerFlexGrowValue');
    setupContainerRangeControl('flexShrink', 'containerFlexShrinkRange', 'containerFlexShrinkValue');
    setupContainerRangeControl('flexBasis', 'containerFlexBasisRange', 'containerFlexBasisValue', 'px');

    // Container size controls (defaulting to % unit)
    setupContainerRangeControl('width', 'containerWidthRange', 'containerWidthValue', '%');
    setupContainerRangeControl('height', 'containerHeightRange', 'containerHeightValue', '%');

    function updateControlsFromContainer() {
      if (!selectedContainer) return;

      const style = selectedContainer.element.style;
      const computedStyle = getComputedStyle(selectedContainer.element);

      // Update radio buttons based on current styles
      const properties = ['flexDirection', 'flexWrap', 'justifyContent', 'alignItems', 'alignContent'];
      properties.forEach(prop => {
        const value = style[prop] || computedStyle[prop] || getDefaultValue(prop);
        const radio = document.querySelector(`input[name="${prop}"][value="${value}"]`);
        if (radio) radio.checked = true;

        // Update direction arrow when displaying current direction
        if (prop === 'flexDirection') {
          updateDirectionArrow(value);
        }
      });

      // Update wrap arrow after all properties are set
      const flexDirection = style.flexDirection || computedStyle.flexDirection || 'row';
      const flexWrap = style.flexWrap || computedStyle.flexWrap || 'nowrap';
      updateWrapArrow(flexDirection, flexWrap);

      // Update overflow/scroll controls
      const overflowValue = style.overflow || computedStyle.overflow || 'visible';
      const overflowRadio = document.querySelector(`input[name="containerOverflow"][value="${overflowValue}"]`);
      if (overflowRadio) overflowRadio.checked = true;

      // Update align-content section state based on flex-wrap
      const flexWrapValue = style.flexWrap || computedStyle.flexWrap || 'nowrap';
      const alignContentSection = document.getElementById('alignContentSection');
      const isWrapEnabled = flexWrapValue !== 'nowrap';

      if (isWrapEnabled) {
        alignContentSection.style.opacity = '1';
        alignContentSection.style.pointerEvents = 'auto';
      } else {
        alignContentSection.style.opacity = '0.5';
        alignContentSection.style.pointerEvents = 'none';
      }

      // Update container size controls (only use explicit styles, not computed values)
      const width = style.width || 'auto';
      const widthNumeric = width === 'auto' ? '0' : parseFloat(width) || '0';
      document.getElementById('containerWidthRange').value = widthNumeric;
      document.getElementById('containerWidthValue').value = width;

      const height = style.height || 'auto';
      const heightNumeric = height === 'auto' ? '0' : parseFloat(height) || '0';
      document.getElementById('containerHeightRange').value = heightNumeric;
      document.getElementById('containerHeightValue').value = height;

      // Update container as flex item controls (only for nested containers)
      if (selectedContainer.id !== 'rootContainer') {
        // Update align self
        const alignSelfValue = style.alignSelf || computedStyle.alignSelf || 'auto';
        const alignSelfRadio = document.querySelector(`input[name="containerAlignSelf"][value="${alignSelfValue}"]`);
        if (alignSelfRadio) alignSelfRadio.checked = true;

        // Update flex grow
        const flexGrow = style.flexGrow || computedStyle.flexGrow || '0';
        document.getElementById('containerFlexGrowRange').value = flexGrow;
        document.getElementById('containerFlexGrowValue').value = flexGrow;

        // Update flex shrink
        const flexShrink = style.flexShrink || computedStyle.flexShrink || '1';
        document.getElementById('containerFlexShrinkRange').value = flexShrink;
        document.getElementById('containerFlexShrinkValue').value = flexShrink;

        // Update flex basis
        const flexBasis = style.flexBasis || computedStyle.flexBasis || 'auto';
        const flexBasisNumeric = flexBasis === 'auto' ? '0' : parseFloat(flexBasis) || '0';
        document.getElementById('containerFlexBasisRange').value = flexBasisNumeric;
        document.getElementById('containerFlexBasisValue').value = flexBasis;
      }
    }

    function getDefaultValue(property) {
      const defaults = {
        flexDirection: 'row',
        flexWrap: 'nowrap',
        justifyContent: 'flex-start',
        alignItems: 'stretch',        // CSS spec default
        alignContent: 'stretch',      // CSS spec default
        overflow: 'visible'
      };
      return defaults[property] || '';
    }

    // Helper function to apply styles to all selected containers
    function applyStyleToAllSelected(property, value) {
      if (selectedContainers.length > 0) {
        // Apply to all selected containers
        selectedContainers.forEach(container => {
          container.element.style[property] = value;
        });
      } else if (selectedContainer) {
        // Fallback for backward compatibility
        selectedContainer.element.style[property] = value;
      }
    }

    function updateCSSDisplay() {
      if (selectedContainers.length === 0 && !selectedContainer) return;

      let combinedCSS = '';

      if (selectedContainers.length > 1) {
        // Show combined CSS for all selected containers and their children
        selectedContainers.forEach(container => {
          combinedCSS += generateContainerCSS(container);
          combinedCSS += generateChildrenCSS(container.element);
        });
      } else {
        // Single container mode - show container CSS and its children
        combinedCSS += generateContainerCSS(selectedContainer);
        combinedCSS += generateChildrenCSS(selectedContainer.element);
      }

      document.getElementById('cssInfoTop').textContent = combinedCSS || '/* No custom styles applied */';
    }

    function generateContainerCSS(container) {
      const relevantStyles = [];
      const style = container.element.style;

      if (style.flexDirection && style.flexDirection !== 'row') relevantStyles.push(`  flex-direction: ${style.flexDirection}`);
      if (style.flexWrap && style.flexWrap !== 'nowrap') relevantStyles.push(`  flex-wrap: ${style.flexWrap}`);
      if (style.justifyContent && style.justifyContent !== 'flex-start') relevantStyles.push(`  justify-content: ${style.justifyContent}`);
      if (style.alignItems && style.alignItems !== 'stretch') relevantStyles.push(`  align-items: ${style.alignItems}`);
      if (style.alignContent && style.alignContent !== 'stretch') relevantStyles.push(`  align-content: ${style.alignContent}`);
      if (style.overflow && style.overflow !== 'visible') relevantStyles.push(`  overflow: ${style.overflow}`);

      // Generate CSS selector
      let selector = container.id === 'root' || container.id === 'rootContainer'
        ? '.root-container'
        : `#${container.id}`;

      if (relevantStyles.length > 0) {
        return `${selector} {\n  display: flex;\n${relevantStyles.join(';\n')};\n}\n\n`;
      }
      return '';
    }

    function generateChildrenCSS(parentElement) {
      let childrenCSS = '';

      // Find child containers with custom styles
      const childContainers = parentElement.querySelectorAll('.nested-container');
      childContainers.forEach(childContainer => {
        const style = childContainer.style;
        const childId = childContainer.id;
        const relevantStyles = [];

        // Container flexbox properties
        if (style.flexDirection && style.flexDirection !== 'row') relevantStyles.push(`  flex-direction: ${style.flexDirection}`);
        if (style.flexWrap && style.flexWrap !== 'nowrap') relevantStyles.push(`  flex-wrap: ${style.flexWrap}`);
        if (style.justifyContent && style.justifyContent !== 'flex-start') relevantStyles.push(`  justify-content: ${style.justifyContent}`);
        if (style.alignItems && style.alignItems !== 'stretch') relevantStyles.push(`  align-items: ${style.alignItems}`);
        if (style.alignContent && style.alignContent !== 'stretch') relevantStyles.push(`  align-content: ${style.alignContent}`);
        if (style.overflow && style.overflow !== 'visible') relevantStyles.push(`  overflow: ${style.overflow}`);

        // Container as flex item properties
        if (style.flexGrow && style.flexGrow !== '0') relevantStyles.push(`  flex-grow: ${style.flexGrow}`);
        if (style.flexShrink && style.flexShrink !== '1') relevantStyles.push(`  flex-shrink: ${style.flexShrink}`);
        if (style.flexBasis && style.flexBasis !== 'auto') relevantStyles.push(`  flex-basis: ${style.flexBasis}`);
        if (style.alignSelf && style.alignSelf !== 'auto') relevantStyles.push(`  align-self: ${style.alignSelf}`);

        if (relevantStyles.length > 0) {
          const displayFlex = relevantStyles.some(s => s.includes('flex-direction') || s.includes('justify-content') || s.includes('align-items') || s.includes('align-content') || s.includes('flex-wrap'));
          const prefix = displayFlex ? '  display: flex;\n' : '';
          childrenCSS += `#${childId} {\n${prefix}${relevantStyles.join(';\n')};\n}\n\n`;
        }
      });

      // Find child items with custom styles
      const childItems = parentElement.querySelectorAll('.flex-item');
      const itemStyles = new Map();

      childItems.forEach(item => {
        const style = item.style;
        const relevantStyles = [];

        if (style.fontSize && !item.className.includes('item-')) relevantStyles.push(`  font-size: ${style.fontSize}`);
        if (style.flexGrow && style.flexGrow !== '0') relevantStyles.push(`  flex-grow: ${style.flexGrow}`);
        if (style.flexShrink && style.flexShrink !== '1') relevantStyles.push(`  flex-shrink: ${style.flexShrink}`);
        if (style.flexBasis && style.flexBasis !== 'auto') relevantStyles.push(`  flex-basis: ${style.flexBasis}`);
        if (style.alignSelf && style.alignSelf !== 'auto') relevantStyles.push(`  align-self: ${style.alignSelf}`);
        if (style.width && style.width !== 'auto') relevantStyles.push(`  width: ${style.width}`);
        if (style.height && style.height !== 'auto') relevantStyles.push(`  height: ${style.height}`);

        if (relevantStyles.length > 0) {
          const styleKey = relevantStyles.join(';\n');
          if (!itemStyles.has(styleKey)) {
            itemStyles.set(styleKey, []);
          }
          itemStyles.get(styleKey).push(item.textContent);
        }
      });

      // Generate CSS for items with similar styles
      itemStyles.forEach((items, styles) => {
        const selector = items.length === 1 ?
          `.flex-item:has-text("${items[0]}")` :
          `/* Items: ${items.join(', ')} */\n.flex-item`;
        childrenCSS += `${selector} {\n${styles};\n}\n\n`;
      });

      return childrenCSS;
    }

    // Item control functions
    function setupItemControl(rangeId, textId, property, unit = '') {
      const range = document.getElementById(rangeId);
      const text = document.getElementById(textId);

      range.addEventListener('input', () => {
        const value = range.value;
        text.value = value + unit;
        if (selectedItems.length > 0) {
          if (value == 0 && (property.includes('width') || property.includes('height') || property === 'flexBasis')) {
            applyStyleToAllItems(property, 'auto');
          } else {
            applyStyleToAllItems(property, value + unit);
          }
          updateItemCSSDisplay();
        }
      });

      text.addEventListener('input', () => {
        if (selectedItems.length > 0) {
          applyStyleToAllItems(property, text.value);
          updateItemCSSDisplay();
        }
      });
    }

    // Initialize item controls
    setupItemControl('fontSizeRange', 'fontSizeValue', 'fontSize', 'em');
    setupItemControl('itemFlexGrowRange', 'itemFlexGrowValue', 'flexGrow');
    setupItemControl('itemFlexShrinkRange', 'itemFlexShrinkValue', 'flexShrink');
    setupItemControl('itemFlexBasisRange', 'itemFlexBasisValue', 'flexBasis', 'px');
    setupItemControl('itemWidthRange', 'itemWidthValue', 'width', 'px');
    setupItemControl('itemHeightRange', 'itemHeightValue', 'height', 'px');

    // Item align self
    document.querySelectorAll('input[name="itemAlignSelf"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        if (selectedItems.length > 0) {
          applyStyleToAllItems('alignSelf', e.target.value);
          updateItemCSSDisplay();
        }
      });
    });

    function updateItemControlsFromElement() {
      if (!selectedItem || selectedItems.length === 0) return;

      const style = selectedItem.style;
      const computedStyle = getComputedStyle(selectedItem);

      // Update controls with current values - convert to em for font size (whole numbers only)
      const actualFontSize = style.fontSize || computedStyle.fontSize;

      if (actualFontSize.includes('em')) {
        // Already in em, round to nearest whole number
        const fontSizeInEm = Math.round(parseFloat(actualFontSize));
        document.getElementById('fontSizeValue').value = fontSizeInEm + 'em';
        document.getElementById('fontSizeRange').value = fontSizeInEm;
      } else {
        // Convert px or rem to em using parent font size, round to nearest whole number
        const fontSizeInPx = parseFloat(actualFontSize);
        const parentFontSize = parseFloat(getComputedStyle(selectedItem.parentElement).fontSize);
        const fontSizeInEm = Math.round(fontSizeInPx / parentFontSize);
        document.getElementById('fontSizeValue').value = fontSizeInEm + 'em';
        document.getElementById('fontSizeRange').value = fontSizeInEm;
      }

      document.getElementById('itemFlexGrowValue').value = style.flexGrow || '0';
      document.getElementById('itemFlexGrowRange').value = style.flexGrow || '0';

      document.getElementById('itemFlexShrinkValue').value = style.flexShrink || '0';
      document.getElementById('itemFlexShrinkRange').value = style.flexShrink || '0';

      // Update align self radio
      const alignSelfValue = style.alignSelf || 'auto';
      const alignSelfRadio = document.querySelector(`input[name="itemAlignSelf"][value="${alignSelfValue}"]`);
      if (alignSelfRadio) alignSelfRadio.checked = true;
    }

    function updateItemCSSDisplay() {
      if (selectedItems.length === 0) return;

      if (selectedItems.length === 1) {
        // Single item - show specific styles with proper CSS block
        const relevantStyles = [];
        const style = selectedItems[0].style;
        const item = selectedItems[0];

        if (style.fontSize && style.fontSize !== '13px') relevantStyles.push(`  font-size: ${style.fontSize}`);
        if (style.flexGrow && style.flexGrow !== '0') relevantStyles.push(`  flex-grow: ${style.flexGrow}`);
        if (style.flexShrink && style.flexShrink !== '0') relevantStyles.push(`  flex-shrink: ${style.flexShrink}`);
        if (style.flexBasis && style.flexBasis !== 'auto') relevantStyles.push(`  flex-basis: ${style.flexBasis}`);
        if (style.width && style.width !== 'auto') relevantStyles.push(`  width: ${style.width}`);
        if (style.height && style.height !== 'auto') relevantStyles.push(`  height: ${style.height}`);
        if (style.alignSelf && style.alignSelf !== 'auto') relevantStyles.push(`  align-self: ${style.alignSelf}`);
        if (style.order && style.order !== '0') relevantStyles.push(`  order: ${style.order}`);

        // Generate CSS selector - use class selector based on text content or a more generic approach
        const itemText = item.textContent;
        const selector = `.flex-item:nth-child(n) /* ${itemText} */`;

        if (relevantStyles.length > 0) {
          document.getElementById('cssInfoTop').textContent = `${selector} {\n${relevantStyles.join(';\n')};\n}`;
        } else {
          document.getElementById('cssInfoTop').textContent = `${selector} {\n  /* No custom styles applied */\n}`;
        }
      } else {
        // Multiple items - show combined CSS
        let combinedCSS = '';
        selectedItems.forEach((item, index) => {
          const relevantStyles = [];
          const style = item.style;
          const itemText = item.textContent;

          if (style.fontSize && style.fontSize !== '13px') relevantStyles.push(`  font-size: ${style.fontSize}`);
          if (style.flexGrow && style.flexGrow !== '0') relevantStyles.push(`  flex-grow: ${style.flexGrow}`);
          if (style.flexShrink && style.flexShrink !== '0') relevantStyles.push(`  flex-shrink: ${style.flexShrink}`);
          if (style.flexBasis && style.flexBasis !== 'auto') relevantStyles.push(`  flex-basis: ${style.flexBasis}`);
          if (style.width && style.width !== 'auto') relevantStyles.push(`  width: ${style.width}`);
          if (style.height && style.height !== 'auto') relevantStyles.push(`  height: ${style.height}`);
          if (style.alignSelf && style.alignSelf !== 'auto') relevantStyles.push(`  align-self: ${style.alignSelf}`);
          if (style.order && style.order !== '0') relevantStyles.push(`  order: ${style.order}`);

          const selector = `.flex-item:nth-child(n) /* ${itemText} */`;

          if (relevantStyles.length > 0) {
            combinedCSS += `${selector} {\n${relevantStyles.join(';\n')};\n}\n\n`;
          }
        });

        document.getElementById('cssInfoTop').textContent = combinedCSS || `/* ${selectedItems.length} items selected - no custom styles applied */`;
      }
    }

    // Action buttons
    document.getElementById('addContainer').addEventListener('click', () => {
      console.log('Add container clicked'); // Debug

      // Use selected container or root as default
      let targetContainer;
      if (selectedContainer && selectedContainer.element) {
        // selectedContainer is an object with element property
        targetContainer = selectedContainer.element;
      } else {
        // Default to root container
        targetContainer = document.getElementById('rootContainer');
      }
      console.log('Target container:', targetContainer ? targetContainer.id : 'null'); // Debug

      // Find next available container ID
      let nextId = 1;
      while (document.getElementById(`container${nextId}`)) {
        nextId++;
      }

      console.log('Next available container ID:', nextId); // Debug
      const newContainer = document.createElement('div');
      newContainer.className = 'nested-container';
      newContainer.id = `container${nextId}`;
      newContainer.setAttribute('data-container', `container${nextId}`);
      newContainer.setAttribute('data-label', `Container ${String.fromCharCode(64 + nextId)}`);
      console.log('Creating container with ID:', newContainer.id); // Debug

      // Set default flex styles
      newContainer.style.display = 'flex';
      newContainer.style.flexDirection = 'column';
      newContainer.style.justifyContent = 'flex-start';
      newContainer.style.alignItems = 'stretch';  // CSS spec default

      // Add some items
      const labels = ['1', '2'];
      labels.forEach((label, index) => {
        const item = document.createElement('div');
        const fontSizes = ['item-small', 'item-medium', 'item-large'];
        const randomSize = fontSizes[Math.floor(Math.random() * fontSizes.length)];
        item.className = `flex-item ${randomSize}`;
        item.textContent = `${String.fromCharCode(64 + nextId)}${index + 1}`;

        // Click event handled by document listener for multi-selection support

        newContainer.appendChild(item);
      });

      // Container click handled by document listener for multi-selection support

      targetContainer.appendChild(newContainer);
      itemCounter[`container${nextId}`] = 2;

      // Add to hierarchy
      const hierarchyItem = document.createElement('div');
      hierarchyItem.className = 'hierarchy-item nested';
      hierarchyItem.setAttribute('data-container', `container${nextId}`);
      hierarchyItem.textContent = `ðŸ“¦ Container ${String.fromCharCode(64 + nextId)}`;

      // Hierarchy item click handled by document listener for multi-selection support

      document.getElementById('hierarchy').appendChild(hierarchyItem);

      console.log('Container added:', newContainer.id); // Debug
    });

    document.getElementById('removeContainer').addEventListener('click', () => {
      console.log('Remove container clicked, selectedContainers:', selectedContainers.length); // Debug

      // Check if we have containers to remove
      const containersToRemove = selectedContainers.length > 0 ? selectedContainers :
                                (selectedContainer ? [selectedContainer] : []);

      if (containersToRemove.length === 0) {
        console.log('No containers selected');
        return;
      }

      // Filter out root container (cannot be removed)
      const removableContainers = containersToRemove.filter(container =>
        container.id !== 'root' && container.id !== 'rootContainer'
      );

      if (removableContainers.length === 0) {
        console.log('Cannot remove root container(s)');
        return;
      }

      // Remove all selected containers
      removableContainers.forEach(container => {
        const containerToRemove = container.element;
        const containerId = container.id;
        console.log('Removing container:', containerId);

        // Remove from DOM
        containerToRemove.remove();

        // Remove from hierarchy
        const hierarchyItem = document.querySelector(`.hierarchy-item[data-container="${containerId}"]`);
        if (hierarchyItem) {
          hierarchyItem.remove();
          console.log('Hierarchy item removed:', containerId);
        }

        // Clean up item counter
        delete itemCounter[containerId];
      });

      // Clear selection
      clearSelection();

      console.log('Containers removed successfully:', removableContainers.map(c => c.id));
    });

    document.getElementById('addItem').addEventListener('click', () => {
      if (!selectedContainer || selectedContainer.id === 'root') return;

      const containerId = selectedContainer.id;
      itemCounter[containerId]++;

      const item = document.createElement('div');
      const fontSizes = ['item-small', 'item-medium', 'item-large'];
      const randomSize = fontSizes[Math.floor(Math.random() * fontSizes.length)];
      item.className = `flex-item ${randomSize}`;

      // Get the letter from the container's data-label attribute
      const containerLabel = selectedContainer.element.getAttribute('data-label');
      const containerLetter = containerLabel ? containerLabel.split(' ')[1] : containerId.slice(-1).toUpperCase();
      item.textContent = `${containerLetter}${itemCounter[containerId]}`;

      // Click event handled by document listener for multi-selection support

      selectedContainer.element.appendChild(item);
    });

    document.getElementById('removeItem').addEventListener('click', () => {
      console.log('Remove item clicked, selectedItems:', selectedItems.length); // Debug

      // Check if we have items to remove
      const itemsToRemove = selectedItems.length > 0 ? selectedItems :
                           (selectedItem ? [selectedItem] : []);

      if (itemsToRemove.length === 0) {
        console.log('No items selected, trying to remove last item from selected container');
        // If no items are selected, remove the last item from selected container
        if (!selectedContainer || selectedContainer.id === 'rootContainer') return;

        const items = selectedContainer.element.querySelectorAll('.flex-item');
        if (items.length > 0) {
          items[items.length - 1].remove();
          itemCounter[selectedContainer.id]--;
        }
        return;
      }

      // Remove all selected items
      itemsToRemove.forEach(item => {
        const parentContainer = item.parentElement;
        const parentId = parentContainer.id || parentContainer.getAttribute('data-container');

        console.log('Removing item:', item.textContent, 'from container:', parentId);

        // Remove from DOM
        item.remove();

        // Update item counter
        if (parentId && itemCounter[parentId]) {
          itemCounter[parentId]--;
        }
      });

      // Clear selection
      selectedItem = null;
      selectedItems = [];
      lastClickedItem = null;
      document.getElementById('itemControls').style.display = 'none';
      updateButtonStates();
      updateItemCSSDisplay();

      console.log('Items removed successfully:', itemsToRemove.length);
    });

    document.getElementById('resetContainer').addEventListener('click', () => {
      if (selectedContainer) {
        if (selectedContainers.length > 1) {
          // Reset all selected containers
          selectedContainers.forEach(container => {
            container.element.removeAttribute('style');
            container.element.style.alignItems = 'stretch';  // CSS spec default
          });
        } else {
          // Reset single container
          selectedContainer.element.removeAttribute('style');
          selectedContainer.element.style.alignItems = 'stretch';  // CSS spec default
        }
        updateControlsFromContainer();
        updateCSSDisplay();
      } else if (selectedItem) {
        selectedItem.removeAttribute('style');
        updateItemControlsFromElement();
        updateItemCSSDisplay();
      }
    });

    document.getElementById('resetAll').addEventListener('click', () => {
      // Remove all custom styles (excluding problem containers)
      document.querySelectorAll('.nested-container, .root-container').forEach(container => {
        // Skip problem containers and their children
        if (container.classList.contains('problem-container') ||
            container.closest('.problem-container')) {
          return;
        }
        container.removeAttribute('style');
        container.classList.remove('selected');
      });
      document.querySelectorAll('.flex-item').forEach(item => {
        // Skip items in problem containers
        if (item.closest('.problem-container')) {
          return;
        }
        item.removeAttribute('style');
        item.classList.remove('selected-item');
      });
      document.querySelectorAll('.hierarchy-item').forEach(item => {
        item.classList.remove('selected');
      });

      // Clear selections
      selectedContainer = null;
      selectedItem = null;
      selectedItems = [];
      lastClickedItem = null;
      document.getElementById('containerControls').style.display = 'none';
      document.getElementById('itemControls').style.display = 'none';

      // Restore initial state
      initializeContainerDefaults();
    });

    document.getElementById('copyContainerCSS').addEventListener('click', () => {
      if (selectedContainer && document.getElementById('cssInfoTop').textContent !== 'Default flex properties') {
        const css = `.container {\n  display: flex;\n  ${document.getElementById('cssInfoTop').textContent.replace(/;\n/g, ';\n  ')}\n}`;
        navigator.clipboard.writeText(css);
        alert('CSS copied to clipboard!');
      }
    });



    document.getElementById('randomizeLayout').addEventListener('click', () => {
      // Only randomize containers that are NOT problem containers
      const containers = Array.from(document.querySelectorAll('.nested-container, .root-container')).filter(container => {
        return !container.classList.contains('problem-container') && !container.closest('.problem-container');
      });

      containers.forEach(container => {
        const directions = ['row', 'column', 'row-reverse', 'column-reverse'];
        const justifies = ['flex-start', 'center', 'flex-end', 'space-between', 'space-around'];
        const aligns = ['stretch', 'flex-start', 'center', 'flex-end'];
        const overflows = ['hidden', 'auto'];

        container.style.flexDirection = directions[Math.floor(Math.random() * directions.length)];
        container.style.justifyContent = justifies[Math.floor(Math.random() * justifies.length)];
        container.style.alignItems = aligns[Math.floor(Math.random() * aligns.length)];
        container.style.overflow = overflows[Math.floor(Math.random() * overflows.length)];
      });

      // Randomly modify flex properties on up to 2 containers
      const containersToModify = containers.sort(() => 0.5 - Math.random()).slice(0, 2);
      containersToModify.forEach(container => {
        const flexWraps = ['nowrap', 'wrap', 'wrap-reverse'];
        const alignContents = ['flex-start', 'center', 'flex-end', 'space-between', 'space-around', 'stretch'];

        if (Math.random() > 0.5) {
          container.style.flexWrap = flexWraps[Math.floor(Math.random() * flexWraps.length)];
          if (container.style.flexWrap !== 'nowrap') {
            container.style.alignContent = alignContents[Math.floor(Math.random() * alignContents.length)];
          }
        }
      });

      // Randomly modify properties on up to 2 flex items
      const allItems = Array.from(document.querySelectorAll('.flex-item')).filter(item => {
        return !item.closest('.problem-container');
      });

      const itemsToModify = allItems.sort(() => 0.5 - Math.random()).slice(0, 2);
      itemsToModify.forEach(item => {
        const grows = ['0', '1', '2'];
        const shrinks = ['0', '1', '2'];
        const alignSelfs = ['auto', 'flex-start', 'center', 'flex-end', 'stretch'];

        if (Math.random() > 0.3) item.style.flexGrow = grows[Math.floor(Math.random() * grows.length)];
        if (Math.random() > 0.3) item.style.flexShrink = shrinks[Math.floor(Math.random() * shrinks.length)];
        if (Math.random() > 0.5) item.style.alignSelf = alignSelfs[Math.floor(Math.random() * alignSelfs.length)];
      });

      // Hide the problem when randomizing
      const problemsContainer = document.getElementById('problemsContainer');
      const problemButton = document.getElementById('createProblem');
      if (problemsContainer.children.length > 0) {
        problemsContainer.innerHTML = '';
        problemButton.textContent = 'Problem';
      }

      if (selectedContainer) {
        updateControlsFromContainer();
        updateCSSDisplay();
      }
    });

    let isUpdatingCheckbox = false;

    document.getElementById('selectAllContainersToggle').addEventListener('change', (e) => {
      // Ignore programmatic updates
      if (isUpdatingCheckbox) {
        console.log('DEBUG Ignoring programmatic checkbox change');
        return;
      }

      console.log('DEBUG User checkbox change:', e.target.checked);

      if (e.target.checked) {
        selectAllContainers();
      } else {
        // Exit multi-select mode and clear all selections
        isMultiSelectMode = false;
        document.querySelectorAll('.nested-container, .root-container').forEach(container => {
          container.classList.remove('selected');
        });
        document.querySelectorAll('.hierarchy-item').forEach(item => {
          item.classList.remove('selected');
        });
        selectedContainers = [];
        selectedContainer = null;
        hideContainerUI();
        updateButtonStates();
        updateCSSDisplay();
      }
    });

    // Initialize default styles for all containers
    function initializeContainerDefaults() {
      const allContainers = document.querySelectorAll('.root-container, .nested-container');
      allContainers.forEach(container => {
        // Set actual CSS flexbox defaults according to specification
        container.style.alignItems = 'stretch';  // CSS spec default
        // Note: Other defaults don't need to be set as they're browser defaults:
        // flex-direction: row, flex-wrap: nowrap, justify-content: flex-start
      });

      // Initialize align-content section as disabled (since default is nowrap)
      const alignContentSection = document.getElementById('alignContentSection');
      alignContentSection.style.opacity = '0.5';
      alignContentSection.style.pointerEvents = 'none';
    }

    // Container clicks handled by document listener for multi-selection support

    // Removed individual item event listeners to allow multi-selection with modifier keys

    // Hierarchy item clicks handled by document click handler to allow multi-selection

    // Background click handling moved to main document click handler

    // Function to clone container with all its styles and content
    function cloneContainerWithStyles(sourceContainer) {
      // Create a deep clone of the container
      const clone = sourceContainer.cloneNode(true);

      // Copy all computed styles from source to clone
      const sourceStyles = window.getComputedStyle(sourceContainer);
      clone.style.cssText = sourceContainer.style.cssText;

      // Apply the problem-container class styling
      clone.className = 'problem-container';

      // Remove any selection classes and IDs to avoid conflicts
      clone.classList.remove('selected');
      clone.removeAttribute('id');

      // Recursively copy styles for all child elements
      function copyStylesToChildren(sourceElement, cloneElement) {
        const sourceChildren = sourceElement.children;
        const cloneChildren = cloneElement.children;

        for (let i = 0; i < sourceChildren.length; i++) {
          if (sourceChildren[i] && cloneChildren[i]) {
            // Copy the style attribute
            cloneChildren[i].style.cssText = sourceChildren[i].style.cssText;

            // Remove selection classes and IDs
            cloneChildren[i].classList.remove('selected', 'selected-item');
            cloneChildren[i].removeAttribute('id');

            // Recursively copy styles for nested children
            copyStylesToChildren(sourceChildren[i], cloneChildren[i]);
          }
        }
      }

      copyStylesToChildren(sourceContainer, clone);
      return clone;
    }

    // Problem button toggle functionality
    document.getElementById('createProblem').addEventListener('click', () => {
      const problemsContainer = document.getElementById('problemsContainer');
      const button = document.getElementById('createProblem');

      // Check if problem is currently shown
      const hasProblem = problemsContainer.children.length > 0;

      if (hasProblem) {
        // Hide the problem
        problemsContainer.innerHTML = '';
        button.textContent = 'Problem';
      } else {
        // Create a new problem
        const rootContainer = document.getElementById('rootContainer');

        // Step 1: Randomize the root container layout
        const directions = ['row', 'column', 'row-reverse', 'column-reverse'];
        const justifies = ['flex-start', 'center', 'flex-end', 'space-between', 'space-around'];
        const aligns = ['stretch', 'flex-start', 'center', 'flex-end'];
        const overflows = ['hidden', 'auto'];

        const containers = Array.from(document.querySelectorAll('.nested-container, .root-container'));
        containers.forEach(container => {
          container.style.flexDirection = directions[Math.floor(Math.random() * directions.length)];
          container.style.justifyContent = justifies[Math.floor(Math.random() * justifies.length)];
          container.style.alignItems = aligns[Math.floor(Math.random() * aligns.length)];
          container.style.overflow = overflows[Math.floor(Math.random() * overflows.length)];
        });

        // Randomly modify flex properties on up to 2 containers
        const containersToModify = containers.sort(() => 0.5 - Math.random()).slice(0, 2);
        containersToModify.forEach(container => {
          const flexWraps = ['nowrap', 'wrap', 'wrap-reverse'];
          const alignContents = ['flex-start', 'center', 'flex-end', 'space-between', 'space-around', 'stretch'];

          if (Math.random() > 0.5) {
            container.style.flexWrap = flexWraps[Math.floor(Math.random() * flexWraps.length)];
            if (container.style.flexWrap !== 'nowrap') {
              container.style.alignContent = alignContents[Math.floor(Math.random() * alignContents.length)];
            }
          }
        });

        // Randomly modify properties on up to 2 flex items
        const allItems = Array.from(document.querySelectorAll('.flex-item'));
        const itemsToModify = allItems.sort(() => 0.5 - Math.random()).slice(0, 2);
        itemsToModify.forEach(item => {
          const grows = ['0', '1', '2'];
          const shrinks = ['0', '1', '2'];
          const alignSelfs = ['auto', 'flex-start', 'center', 'flex-end', 'stretch'];

          if (Math.random() > 0.3) item.style.flexGrow = grows[Math.floor(Math.random() * grows.length)];
          if (Math.random() > 0.3) item.style.flexShrink = shrinks[Math.floor(Math.random() * shrinks.length)];
          if (Math.random() > 0.5) item.style.alignSelf = alignSelfs[Math.floor(Math.random() * alignSelfs.length)];
        });

        // Step 2: Clone the randomized container to create a problem
        const problemContainer = cloneContainerWithStyles(rootContainer);

        // Step 3: Add the problem container
        problemsContainer.appendChild(problemContainer);
        button.textContent = 'Hide Problem';

        // Step 4: Reset the root container (like resetAll but only for containers, excluding problems)
        document.querySelectorAll('.nested-container, .root-container').forEach(container => {
          // Skip problem containers and their children
          if (container.classList.contains('problem-container') ||
              container.closest('.problem-container')) {
            return;
          }
          container.removeAttribute('style');
          container.classList.remove('selected');
        });
        document.querySelectorAll('.flex-item').forEach(item => {
          // Skip items in problem containers
          if (item.closest('.problem-container')) {
            return;
          }
          item.removeAttribute('style');
          item.classList.remove('selected-item');
        });
        document.querySelectorAll('.hierarchy-item').forEach(item => {
          item.classList.remove('selected');
        });

        // Clear selections and hide UI
        selectedContainer = null;
        selectedItem = null;
        selectedItems = [];
        lastClickedItem = null;
        selectedContainers = [];
        isMultiSelectMode = false;
        document.getElementById('containerControls').style.display = 'none';
        document.getElementById('itemControls').style.display = 'none';
        hideContainerUI();
        updateCSSDisplay();

        // Reinitialize default styles
        initializeContainerDefaults();
      }
    });

    // Initialize with default styles and no container selected
    initializeContainerDefaults();

    // Initialize arrows with default direction (row) and wrap (nowrap)
    updateJustifyAndAlignArrows('row');
    updateWrapArrow('row', 'nowrap');

    // Initialize with no selection and hidden UI
    clearSelection();
  </script>
</body>
</html>